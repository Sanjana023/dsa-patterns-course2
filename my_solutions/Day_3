#1 Merge Sorted Array (LC 88)

class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        
        int i =  m - 1,
            j = n - 1,
            k = m + n - 1;

            while(i >= 0 && j >= 0){
                if(nums1[i] > nums2[j]){
                    nums1[k] = nums1[i];
                    i--;
                }else{
                    nums1[k] = nums2[j];
                    j--;
                }
                k--;
            }
            while (j >= 0) {
                nums1[k] = nums2[j];
                j--;
                k--;
            }

        }
}

#2 Count Pairs Whose Sum is Less than Target

class Solution {
    public int countPairs(List<Integer> nums, int target) {
        //Optimised -> Two pointers
        Collections.sort(nums);
        int i = 0, j = nums.size() - 1;

        int pairs = 0;
        while(i <  j){
            if(nums.get(i) + nums.get(j) < target){
                pairs += j - i;
                i++;
            }else{
                j--;
            }
        }
        return pairs;
    }
}

#3 Two Sum

class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        //O(n)
        for(int i=0;i<nums.length;i++){
            map.put(nums[i], i);
        }
        int i=0;
        int[] ans = new int[2];
        while(i<nums.length){//O(n)
            int val = target - nums[i];
            if(map.containsKey(val) && i != map.get(val)){ //O(1)
                return new int[]{i, map.get(val)};
                }
            map.put(nums[i], i);
            i++;
        }
        return ans;
    }
}
//TC -> O(n)

#4 Two Sum II - Input Array Is Sorted

class Solution {
    public int[] twoSum(int[] nums, int target) {
        int i = 0, j = nums.length - 1;
        while(i < j){
            int sum = nums[i] + nums[j];
            if(sum == target)
            return new int[]{i+1, j+1};
            else if (sum<target) i++;
            else j--;
        }
        return new int[]{-1, -1};
    }
}

#5 3Sum

class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int minDiff = Integer.MAX_VALUE;
        int closestSum = 0;
        for(int i=0;i<nums.length-2;i++){
            int j=i+1;
            int k=nums.length-1;
            while(j<k){
                int sum = nums[i]+nums[j]+nums[k];
                int diff = Math.abs(sum-target);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestSum = sum;
                }
                if(sum>target) k--;
                else if(sum<target) j++;
                else{//best case -> equal to target sum
                    return sum;
                }
            }
        }
        return closestSum;
    }
}

Related problems done âœ…: 4Sum(LC 18), 3Sum Closest(LC 16)
